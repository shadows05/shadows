适配器模式（Adapter Pattern），把一个类的接口变换成客户端所期待的另一种接口， Adapter模式使原本因接口不匹配（或者不兼容）而无法在一起工作的两个类能够在一起工作。
又称为转换器模式、变压器模式、包装（Wrapper）器模式（把已有的一些类包装起来，使之能有满足需要的接口）。

1)类适配器模式
  适配器继承自已实现的类（一般多重继承）。
2)对象适配器模式
  适配器容纳一个它包裹的类的实例。在这种情况下，适配器调用被包裹对象的物理实体。

? 目标角色（Target）：― 定义Client使用的与特定领域相关的接口。
? 客户角色（Client）：与符合Target接口的对象协同。
? 被适配角色（Adaptee)：定义一个已经存在并已经使用的接口，这个接口需要适配。
? 适配器角色（Adapte) ：适配器模式的核心。它将对被适配Adaptee角色已有的接口转换为目标角色Target匹配的接口。对Adaptee的接口与Target接口进行适配.




桥梁模式(bridge模式)：桥梁模式与对象适配器类似，但是桥梁模式的出发点不同：桥梁模式目的是将接口部分和实现部分分离，从而对它们可以较为容易也相对独立的加以改变。而对象适配器模式则意味着改变一个已有对象的接口

装饰器模式(decorator模式)：装饰模式增强了其他对象的功能而同时又不改变它的接口。因此装饰模式对应用的透明性比适配器更好。结果是decorator模式支持递归组合，而纯粹使用适配器是不可能实现这一点的。

Facade（外观模式）：适配器模式的重点是改变一个单独类的API。Facade的目的是给由许多对象构成的整个子系统，提供更为简洁的接口。而适配器模式就是封装一个单独类，适配器模式经常用在需要第三方API协同工作的场合，设法把你的代码与第三方库隔离开来。

适配器模式与外观模式都是对现相存系统的封装。但这两种模式的意图完全不同，前者使现存系统与正在设计的系统协同工作而后者则为现存系统提供一个更为方便的访问接口。简单地说，适配器模式为事后设计，而外观模式则必须事前设计，因为系统依靠于外观。总之，适配器模式没有引入新的接口，而外观模式则定义了一个全新的接口。


代理模式（Proxy ）在不改变它的接口的条件下，为另一个对象定义了一个代理。
装饰者模式，适配器模式，外观模式三者之间的区别：
装饰者模式的话，它并不会改变接口，而是将一个一个的接口进行装饰，也就是添加新的功能。
适配器模式是将一个接口通过适配来间接转换为另一个接口。
外观模式的话，其主要是提供一个整洁的一致的接口给客户端。